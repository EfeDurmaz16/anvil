package typescript

import (
	"context"
	"fmt"
	"sort"
	"strings"

	"github.com/efebarandurmaz/anvil/internal/ir"
	"github.com/efebarandurmaz/anvil/internal/llm"
	"github.com/efebarandurmaz/anvil/internal/plugins"
)

// Plugin implements TargetPlugin for TypeScript.
type Plugin struct{}

func New() *Plugin { return &Plugin{} }

func (p *Plugin) Language() string { return "typescript" }

func (p *Plugin) Generate(ctx context.Context, graph *ir.SemanticGraph, provider llm.Provider) ([]plugins.GeneratedFile, error) {
	var files []plugins.GeneratedFile

	// Emit module services.
	for _, mod := range graph.Modules {
		svcName := toPascalCase(mod.Name) + "Service"
		var content string
		if provider != nil {
			// Use LLM to generate actual implementation
			content = generateServiceWithLLM(ctx, mod, svcName, graph, provider)
		} else {
			// Fallback to stub generation
			content = generateService(mod, svcName)
		}
		files = append(files, plugins.GeneratedFile{
			Path:    fmt.Sprintf("src/generated/%s.ts", toKebabCase(mod.Name)),
			Content: []byte(content),
		})
	}

	// Emit model types.
	files = append(files, plugins.GeneratedFile{
		Path:    "src/generated/model.ts",
		Content: []byte(generateModels(graph.DataTypes)),
	})

	// Barrel export.
	files = append(files, plugins.GeneratedFile{
		Path:    "src/generated/index.ts",
		Content: []byte(generateIndex(graph.Modules)),
	})

	return files, nil
}

// generateServiceWithLLM uses the LLM to generate TypeScript implementations.
func generateServiceWithLLM(ctx context.Context, mod *ir.Module, svcName string, graph *ir.SemanticGraph, provider llm.Provider) string {
	var b strings.Builder
	b.WriteString("/* Generated by Anvil with LLM assistance. */\n")
	b.WriteString("import { type UnknownRecord } from \"./model\";\n\n")

	// Generate model imports based on types used
	imports := collectModelImports(mod, graph.DataTypes)
	if len(imports) > 0 {
		b.WriteString(fmt.Sprintf("import { %s } from \"./model\";\n\n", strings.Join(imports, ", ")))
	}

	b.WriteString(fmt.Sprintf("export class %s {\n", svcName))

	for _, fn := range mod.Functions {
		// Build context for LLM
		fnContext := buildFunctionContext(mod, fn, graph)

		// Generate function implementation via LLM
		impl := generateFunctionWithLLM(ctx, fn, fnContext, provider)
		b.WriteString(impl)
	}

	b.WriteString("}\n")
	return b.String()
}

// buildFunctionContext creates context for LLM code generation.
func buildFunctionContext(mod *ir.Module, fn *ir.Function, graph *ir.SemanticGraph) string {
	var ctx strings.Builder
	ctx.WriteString(fmt.Sprintf("Module: %s\n", mod.Name))
	ctx.WriteString(fmt.Sprintf("Function: %s\n", fn.Name))

	if fn.Body != "" {
		ctx.WriteString(fmt.Sprintf("Original COBOL Body:\n%s\n", fn.Body))
	}

	// Include business rules if available
	for _, rule := range graph.BusinessRules {
		if rule.SourceRef == fmt.Sprintf("%s.%s", mod.Name, fn.Name) {
			ctx.WriteString(fmt.Sprintf("Business Rule: %s (confidence: %.2f)\n", rule.Description, rule.Confidence))
		}
	}

	// Include parameter info
	if len(fn.Parameters) > 0 {
		ctx.WriteString("Parameters:\n")
		for _, p := range fn.Parameters {
			ctx.WriteString(fmt.Sprintf("  - %s: %s\n", p.Name, describeType(p.Type)))
		}
	}

	// Include return type info
	if fn.Returns != nil {
		ctx.WriteString(fmt.Sprintf("Returns: %s\n", describeType(fn.Returns)))
	}

	return ctx.String()
}

// generateFunctionWithLLM generates a single function implementation using LLM.
func generateFunctionWithLLM(ctx context.Context, fn *ir.Function, fnContext string, provider llm.Provider) string {
	prompt := &llm.Prompt{
		SystemPrompt: `You are a COBOL to TypeScript migration expert. Generate clean, idiomatic TypeScript code.
Rules:
1. Preserve the exact business logic from the original COBOL
2. Use modern TypeScript features (async/await, optional chaining, etc.)
3. Add proper type annotations
4. Include JSDoc comments explaining the business logic
5. Handle edge cases and errors appropriately
6. Return ONLY the TypeScript function body (no class wrapper)
7. CRITICAL: Use Decimal.js for ALL financial/monetary calculations to preserve COBOL precision
   - Import: import Decimal from 'decimal.js';
   - Use: new Decimal(value).plus(other).toNumber()
   - Never use native JavaScript number arithmetic for money`,
		Messages: []llm.Message{
			{Role: llm.RoleUser, Content: fmt.Sprintf("Convert this COBOL function to TypeScript:\n\n%s", fnContext)},
		},
	}

	resp, err := provider.Complete(ctx, prompt, nil)
	if err != nil {
		// Fallback to stub on error
		return generateFunctionStub(fn)
	}

	// Extract and format the response
	impl := strings.TrimSpace(resp.Content)

	// Wrap in method signature
	var b strings.Builder
	b.WriteString(fmt.Sprintf("  /**\n   * Migrated from COBOL: %s\n", fn.Name))
	if fn.Body != "" {
		// Add truncated original as reference
		orig := fn.Body
		if len(orig) > 200 {
			orig = orig[:200] + "..."
		}
		b.WriteString(fmt.Sprintf("   * Original: %s\n", strings.ReplaceAll(orig, "\n", "\n   * ")))
	}
	b.WriteString("   */\n")

	// Generate method signature with proper types
	params := generateParamList(fn)
	returnType := generateReturnType(fn)

	b.WriteString(fmt.Sprintf("  %s(%s): %s {\n", toCamelCase(fn.Name), params, returnType))

	// Indent the implementation
	for _, line := range strings.Split(impl, "\n") {
		b.WriteString("    " + line + "\n")
	}

	b.WriteString("  }\n\n")
	return b.String()
}

// generateFunctionStub generates a stub when LLM is unavailable.
func generateFunctionStub(fn *ir.Function) string {
	var b strings.Builder
	params := generateParamList(fn)
	returnType := generateReturnType(fn)

	b.WriteString(fmt.Sprintf("  /** Migrated from %s */\n", fn.Name))
	b.WriteString(fmt.Sprintf("  %s(%s): %s {\n", toCamelCase(fn.Name), params, returnType))
	b.WriteString("    // TODO: implement migrated logic\n")
	b.WriteString("    throw new Error('Not implemented');\n")
	b.WriteString("  }\n\n")
	return b.String()
}

// generateParamList generates TypeScript parameter list from IR.
func generateParamList(fn *ir.Function) string {
	if len(fn.Parameters) == 0 {
		return "_input?: UnknownRecord"
	}

	var params []string
	for _, p := range fn.Parameters {
		params = append(params, fmt.Sprintf("%s: %s", toCamelCase(p.Name), mapType(p.Type)))
	}
	return strings.Join(params, ", ")
}

// generateReturnType generates TypeScript return type from IR.
func generateReturnType(fn *ir.Function) string {
	if fn.Returns == nil {
		return "void"
	}
	return mapType(fn.Returns)
}

// collectModelImports collects type names used in a module.
func collectModelImports(mod *ir.Module, _ []*ir.DataType) []string {
	used := make(map[string]bool)
	for _, fn := range mod.Functions {
		for _, p := range fn.Parameters {
			if p.Type != nil && p.Type.Kind == ir.TypeStruct {
				used[toPascalCase(p.Type.Name)] = true
			}
		}
		if fn.Returns != nil && fn.Returns.Kind == ir.TypeStruct {
			used[toPascalCase(fn.Returns.Name)] = true
		}
	}

	var imports []string
	for name := range used {
		imports = append(imports, name)
	}
	sort.Strings(imports)
	return imports
}

// describeType creates a human-readable type description.
func describeType(dt *ir.DataType) string {
	if dt == nil {
		return "unknown"
	}
	switch dt.Kind {
	case ir.TypeString:
		return "string"
	case ir.TypeInteger:
		return "integer"
	case ir.TypeDecimal:
		return "decimal"
	case ir.TypeBoolean:
		return "boolean"
	case ir.TypeArray:
		return "array of " + describeType(dt.ElementType)
	case ir.TypeStruct:
		return "struct " + dt.Name
	default:
		return "unknown"
	}
}

func (p *Plugin) Scaffold(_ context.Context, _ *ir.SemanticGraph) ([]plugins.GeneratedFile, error) {
	return []plugins.GeneratedFile{
		{Path: "anvil.manifest.json", Content: []byte(anvilManifestJSON)},
		{Path: "package.json", Content: []byte(packageJSON)},
		{Path: "tsconfig.json", Content: []byte(tsconfigJSON)},
		{Path: "src/index.ts", Content: []byte("export * from \"./generated\";\n")},
		{Path: "src/anvil_runner.ts", Content: []byte(anvilRunnerTS)},
	}, nil
}

func generateService(mod *ir.Module, svcName string) string {
	var b strings.Builder
	b.WriteString("/* Generated by Anvil. */\n")
	b.WriteString("import { type UnknownRecord } from \"./model\";\n\n")
	b.WriteString(fmt.Sprintf("export class %s {\n", svcName))
	for _, fn := range mod.Functions {
		b.WriteString(fmt.Sprintf("  /** Migrated from %s.%s */\n", mod.Name, fn.Name))
		b.WriteString(fmt.Sprintf("  %s(_input?: UnknownRecord): void {\n", toCamelCase(fn.Name)))
		b.WriteString("    // TODO: implement migrated logic\n")
		b.WriteString("  }\n\n")
	}
	b.WriteString("}\n")
	return b.String()
}

func generateModels(types []*ir.DataType) string {
	var b strings.Builder
	b.WriteString("/* Generated by Anvil. */\n\n")
	b.WriteString("export type UnknownRecord = Record<string, unknown>;\n\n")

	// Keep output stable.
	sorted := append([]*ir.DataType(nil), types...)
	sort.Slice(sorted, func(i, j int) bool { return sorted[i].Name < sorted[j].Name })

	for _, dt := range sorted {
		if dt == nil || dt.Kind != ir.TypeStruct {
			continue
		}
		b.WriteString(fmt.Sprintf("export interface %s {\n", toPascalCase(dt.Name)))
		for _, f := range dt.Fields {
			if f == nil {
				continue
			}
			b.WriteString(fmt.Sprintf("  %s?: %s;\n", toCamelCase(f.Name), mapType(f)))
		}
		b.WriteString("}\n\n")
	}
	return b.String()
}

func generateIndex(mods []*ir.Module) string {
	var b strings.Builder
	b.WriteString("/* Generated by Anvil. */\n\n")
	b.WriteString("export * from \"./model\";\n")
	for _, m := range mods {
		b.WriteString(fmt.Sprintf("export * from \"./%s\";\n", toKebabCase(m.Name)))
	}
	return b.String()
}

func mapType(dt *ir.DataType) string {
	if dt == nil {
		return "unknown"
	}
	switch dt.Kind {
	case ir.TypeString:
		return "string"
	case ir.TypeInteger, ir.TypeDecimal:
		return "number"
	case ir.TypeBoolean:
		return "boolean"
	case ir.TypeArray:
		if dt.ElementType != nil {
			return "Array<" + mapType(dt.ElementType) + ">"
		}
		return "Array<unknown>"
	case ir.TypeStruct:
		return toPascalCase(dt.Name)
	default:
		return "unknown"
	}
}

func toPascalCase(name string) string {
	parts := strings.FieldsFunc(name, func(r rune) bool {
		return r == '-' || r == '_' || r == ' ' || r == '.'
	})
	var out string
	for _, p := range parts {
		if p == "" {
			continue
		}
		out += strings.ToUpper(p[:1]) + strings.ToLower(p[1:])
	}
	if out == "" {
		return "Generated"
	}
	return out
}

func toCamelCase(name string) string {
	p := toPascalCase(name)
	if p == "" {
		return "unnamed"
	}
	return strings.ToLower(p[:1]) + p[1:]
}

func toKebabCase(name string) string {
	// Best-effort normalization for filenames.
	s := strings.TrimSpace(strings.ToLower(name))
	s = strings.NewReplacer("::", "-", ".", "-", "_", "-", " ", "-").Replace(s)
	for strings.Contains(s, "--") {
		s = strings.ReplaceAll(s, "--", "-")
	}
	s = strings.Trim(s, "-")
	if s == "" {
		return "generated"
	}
	return s
}

const packageJSON = `{
  "name": "anvil-generated",
  "private": true,
  "type": "module",
  "scripts": {
    "build": "tsc -p tsconfig.json",
    "typecheck": "tsc -p tsconfig.json --noEmit"
  },
  "dependencies": {
    "decimal.js": "^10.4.3"
  },
  "devDependencies": {
    "@types/node": "^20.0.0",
    "typescript": "^5.0.0"
  }
}
`

const tsconfigJSON = `{
  "compilerOptions": {
    "target": "ES2022",
    "module": "ES2022",
    "moduleResolution": "Bundler",
    "strict": true,
    "declaration": true,
    "outDir": "dist",
    "rootDir": "src"
  },
  "include": ["src/**/*.ts"]
}
`

const anvilManifestJSON = `{
  "version": "1",
  "language": "typescript",
  "compile": [
    { "cmd": "tsc", "args": ["-p", "tsconfig.json"] }
  ],
  "run_fixture": { "cmd": "node", "args": ["dist/anvil_runner.js"] }
}
`

const anvilRunnerTS = `/* Generated by Anvil. */
import fs from "node:fs";

type Fixture = {
  kind: string;
  name: string;
  correlation_id?: string;
  http?: { method: string; path: string; header?: Record<string, string>; body?: unknown };
  batch?: unknown;
};

type ActualOutput = {
  status?: number;
  headers?: Record<string, string>;
  body?: unknown;
};

function readStdin(): string {
  return fs.readFileSync(0, "utf8");
}

function main() {
  const raw = readStdin();
  let fixture: Fixture | null = null;
  try {
    fixture = JSON.parse(raw) as Fixture;
  } catch {
    // ignore
  }

  const out: ActualOutput = {
    status: 501,
    headers: { "content-type": "application/json" },
    body: { error: "not implemented", fixture: fixture?.name ?? null }
  };

  process.stdout.write(JSON.stringify(out));
}

main();
`
