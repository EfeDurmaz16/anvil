package typescript

import (
	"context"
	"fmt"
	"sort"
	"strings"
	"sync"

	"github.com/efebarandurmaz/anvil/internal/ir"
	"github.com/efebarandurmaz/anvil/internal/llm"
	"github.com/efebarandurmaz/anvil/internal/plugins"
)

// Plugin implements TargetPlugin for TypeScript.
type Plugin struct{}

func New() *Plugin { return &Plugin{} }

func (p *Plugin) Language() string { return "typescript" }

func (p *Plugin) Generate(ctx context.Context, graph *ir.SemanticGraph, provider llm.Provider) ([]plugins.GeneratedFile, error) {
	var files []plugins.GeneratedFile

	// Emit module services.
	for _, mod := range graph.Modules {
		svcName := toPascalCase(mod.Name) + "Service"
		var content string
		if provider != nil {
			// Use LLM to generate actual implementation
			content = generateServiceWithLLM(ctx, mod, svcName, graph, provider)
		} else {
			// Fallback to stub generation
			content = generateService(mod, svcName)
		}
		files = append(files, plugins.GeneratedFile{
			Path:    fmt.Sprintf("src/generated/%s.ts", toKebabCase(mod.Name)),
			Content: []byte(content),
		})
	}

	// Emit model types.
	files = append(files, plugins.GeneratedFile{
		Path:    "src/generated/model.ts",
		Content: []byte(generateModels(graph.DataTypes)),
	})

	// Barrel export.
	files = append(files, plugins.GeneratedFile{
		Path:    "src/generated/index.ts",
		Content: []byte(generateIndex(graph.Modules)),
	})

	return files, nil
}

// generateServiceWithLLM uses the LLM to generate TypeScript implementations.
func generateServiceWithLLM(ctx context.Context, mod *ir.Module, svcName string, graph *ir.SemanticGraph, provider llm.Provider) string {
	var b strings.Builder
	b.WriteString("/* Generated by Anvil with LLM assistance. */\n")
	b.WriteString("import { type UnknownRecord } from \"./model\";\n\n")

	// Generate model imports based on types used
	imports := collectModelImports(mod, graph.DataTypes)
	if len(imports) > 0 {
		b.WriteString(fmt.Sprintf("import { %s } from \"./model\";\n\n", strings.Join(imports, ", ")))
	}

	b.WriteString(fmt.Sprintf("export class %s {\n", svcName))

	// Generate functions concurrently with worker pool
	const maxConcurrent = 5
	sem := make(chan struct{}, maxConcurrent)
	var wg sync.WaitGroup
	var mu sync.Mutex

	results := make([]string, len(mod.Functions))

	for i, fn := range mod.Functions {
		wg.Add(1)
		sem <- struct{}{} // acquire
		go func(idx int, f *ir.Function) {
			defer wg.Done()
			defer func() { <-sem }() // release

			// Build context for LLM
			fnContext := buildFunctionContext(mod, f, graph)

			// Generate function implementation via LLM
			impl := generateFunctionWithLLM(ctx, f, fnContext, provider)

			mu.Lock()
			results[idx] = impl
			mu.Unlock()
		}(i, fn)
	}
	wg.Wait()

	// Write results in order
	for _, impl := range results {
		b.WriteString(impl)
	}

	b.WriteString("}\n")
	return b.String()
}

// buildFunctionContext creates context for LLM code generation.
func buildFunctionContext(mod *ir.Module, fn *ir.Function, graph *ir.SemanticGraph) string {
	var ctx strings.Builder
	ctx.WriteString(fmt.Sprintf("Module: %s\n", mod.Name))
	ctx.WriteString(fmt.Sprintf("Function: %s\n", fn.Name))

	if fn.Body != "" {
		lang := mod.Language
		if lang == "" {
			lang = "legacy"
		}
		ctx.WriteString(fmt.Sprintf("Original %s Body:\n%s\n", lang, fn.Body))
	}

	// Include business rules if available
	for _, rule := range graph.BusinessRules {
		if rule.SourceRef == fmt.Sprintf("%s.%s", mod.Name, fn.Name) {
			ctx.WriteString(fmt.Sprintf("Business Rule: %s (confidence: %.2f)\n", rule.Description, rule.Confidence))
		}
	}

	// Include parameter info
	if len(fn.Parameters) > 0 {
		ctx.WriteString("Parameters:\n")
		for _, p := range fn.Parameters {
			ctx.WriteString(fmt.Sprintf("  - %s: %s\n", p.Name, describeType(p.Type)))
		}
	}

	// Include return type info
	if fn.Returns != nil {
		ctx.WriteString(fmt.Sprintf("Returns: %s\n", describeType(fn.Returns)))
	}

	return ctx.String()
}

// stripMarkdownFences removes markdown code fences from LLM output.
func stripMarkdownFences(s string) string {
	lines := strings.Split(s, "\n")

	// Find and remove leading fence
	start := 0
	for i, line := range lines {
		trimmed := strings.TrimSpace(line)
		if strings.HasPrefix(trimmed, "```") {
			start = i + 1
			break
		}
	}

	// Find and remove trailing fence
	end := len(lines)
	for i := len(lines) - 1; i >= start; i-- {
		trimmed := strings.TrimSpace(lines[i])
		if strings.HasPrefix(trimmed, "```") {
			end = i
			break
		}
	}

	// If no fences found, return original
	if start == 0 && end == len(lines) {
		return s
	}

	return strings.Join(lines[start:end], "\n")
}

// sanitizeLLMOutput strips import/export statements and standalone function
// wrappers that LLMs commonly include despite instructions not to.
func sanitizeLLMOutput(s string) string {
	lines := strings.Split(s, "\n")
	var cleaned []string
	for _, line := range lines {
		trimmed := strings.TrimSpace(line)
		// Skip import statements
		if strings.HasPrefix(trimmed, "import ") {
			continue
		}
		// Skip export statements
		if strings.HasPrefix(trimmed, "export ") {
			continue
		}
		// Strip trailing prose (non-code text after the implementation)
		if strings.HasPrefix(trimmed, "This ") || strings.HasPrefix(trimmed, "Note:") || strings.HasPrefix(trimmed, "The above") {
			break
		}
		cleaned = append(cleaned, line)
	}
	// Trim trailing empty lines
	for len(cleaned) > 0 && strings.TrimSpace(cleaned[len(cleaned)-1]) == "" {
		cleaned = cleaned[:len(cleaned)-1]
	}
	return strings.Join(cleaned, "\n")
}

// generateFunctionWithLLM generates a single function implementation using LLM.
func generateFunctionWithLLM(ctx context.Context, fn *ir.Function, fnContext string, provider llm.Provider) string {
	lang := "legacy"
	if fn.Name != "" {
		// Extract language from module context if available
		for _, m := range strings.Split(fnContext, "\n") {
			if strings.HasPrefix(m, "Module: ") && strings.Contains(fnContext, "Language:") {
				// Language is embedded in context
				break
			}
		}
	}

	prompt := &llm.Prompt{
		SystemPrompt: fmt.Sprintf(`You are a %s to TypeScript migration expert.

CRITICAL OUTPUT FORMAT RULES:
- Return ONLY the implementation lines that go INSIDE a method body
- Do NOT include import statements (imports are handled externally)
- Do NOT include function/class declarations or export statements
- Do NOT wrap code in markdown fences
- The code will be placed inside a class method, so write only the body
- Use Decimal.js as: new Decimal(value).plus(other).toNumber() â€” assume it is already imported

Example of CORRECT output:
const result = new Decimal(num1).plus(new Decimal(num2));
console.log("SUM: " + result.toNumber());
return result.toNumber();

Example of WRONG output (do NOT do this):
import Decimal from 'decimal.js';
export function addNumbers() {
  ...
}

Rules:
1. Preserve the exact business logic from the original %s code
2. Use modern TypeScript (async/await, optional chaining)
3. Add brief inline comments for business logic
4. Handle edge cases appropriately`, lang, lang),
		Messages: []llm.Message{
			{Role: llm.RoleUser, Content: fmt.Sprintf("Convert this %s function to TypeScript method body:\n\n%s\n\nReturn ONLY the method body lines, no imports or function wrappers.", lang, fnContext)},
		},
	}

	resp, err := provider.Complete(ctx, prompt, nil)
	if err != nil {
		// Fallback to stub on error
		return generateFunctionStub(fn)
	}

	// Extract and format the response
	impl := strings.TrimSpace(stripMarkdownFences(resp.Content))
	impl = sanitizeLLMOutput(impl)

	// Wrap in method signature
	var b strings.Builder
	b.WriteString(fmt.Sprintf("  /**\n   * Migrated from %s: %s\n", lang, fn.Name))
	if fn.Body != "" {
		// Add truncated original as reference
		orig := fn.Body
		if len(orig) > 200 {
			orig = orig[:200] + "..."
		}
		b.WriteString(fmt.Sprintf("   * Original: %s\n", strings.ReplaceAll(orig, "\n", "\n   * ")))
	}
	b.WriteString("   */\n")

	// Generate method signature with proper types
	params := generateParamList(fn)
	returnType := generateReturnType(fn)

	b.WriteString(fmt.Sprintf("  %s(%s): %s {\n", toCamelCase(fn.Name), params, returnType))

	// Indent the implementation
	for _, line := range strings.Split(impl, "\n") {
		b.WriteString("    " + line + "\n")
	}

	b.WriteString("  }\n\n")
	return b.String()
}

// generateFunctionStub generates a stub when LLM is unavailable.
func generateFunctionStub(fn *ir.Function) string {
	var b strings.Builder
	params := generateParamList(fn)
	returnType := generateReturnType(fn)

	b.WriteString(fmt.Sprintf("  /** Migrated from %s */\n", fn.Name))
	b.WriteString(fmt.Sprintf("  %s(%s): %s {\n", toCamelCase(fn.Name), params, returnType))
	b.WriteString("    // TODO: implement migrated logic\n")
	b.WriteString("    throw new Error('Not implemented');\n")
	b.WriteString("  }\n\n")
	return b.String()
}

// generateParamList generates TypeScript parameter list from IR.
func generateParamList(fn *ir.Function) string {
	if len(fn.Parameters) == 0 {
		return "_input?: UnknownRecord"
	}

	var params []string
	for _, p := range fn.Parameters {
		params = append(params, fmt.Sprintf("%s: %s", toCamelCase(p.Name), mapType(p.Type)))
	}
	return strings.Join(params, ", ")
}

// generateReturnType generates TypeScript return type from IR.
func generateReturnType(fn *ir.Function) string {
	if fn.Returns == nil {
		return "void"
	}
	return mapType(fn.Returns)
}

// collectModelImports collects type names used in a module.
func collectModelImports(mod *ir.Module, _ []*ir.DataType) []string {
	used := make(map[string]bool)
	for _, fn := range mod.Functions {
		for _, p := range fn.Parameters {
			if p.Type != nil && p.Type.Kind == ir.TypeStruct {
				used[toPascalCase(p.Type.Name)] = true
			}
		}
		if fn.Returns != nil && fn.Returns.Kind == ir.TypeStruct {
			used[toPascalCase(fn.Returns.Name)] = true
		}
	}

	var imports []string
	for name := range used {
		imports = append(imports, name)
	}
	sort.Strings(imports)
	return imports
}

// describeType creates a human-readable type description.
func describeType(dt *ir.DataType) string {
	if dt == nil {
		return "unknown"
	}
	switch dt.Kind {
	case ir.TypeString:
		return "string"
	case ir.TypeInteger:
		return "integer"
	case ir.TypeDecimal:
		return "decimal"
	case ir.TypeBoolean:
		return "boolean"
	case ir.TypeArray:
		return "array of " + describeType(dt.ElementType)
	case ir.TypeStruct:
		return "struct " + dt.Name
	default:
		return "unknown"
	}
}

func (p *Plugin) Scaffold(_ context.Context, _ *ir.SemanticGraph) ([]plugins.GeneratedFile, error) {
	return []plugins.GeneratedFile{
		{Path: "anvil.manifest.json", Content: []byte(anvilManifestJSON)},
		{Path: "package.json", Content: []byte(packageJSON)},
		{Path: "tsconfig.json", Content: []byte(tsconfigJSON)},
		{Path: "src/index.ts", Content: []byte("export * from \"./generated\";\n")},
		{Path: "src/anvil_runner.ts", Content: []byte(anvilRunnerTS)},
	}, nil
}

func generateService(mod *ir.Module, svcName string) string {
	var b strings.Builder
	b.WriteString("/* Generated by Anvil. */\n")
	b.WriteString("import { type UnknownRecord } from \"./model\";\n\n")
	b.WriteString(fmt.Sprintf("export class %s {\n", svcName))
	for _, fn := range mod.Functions {
		b.WriteString(fmt.Sprintf("  /** Migrated from %s.%s */\n", mod.Name, fn.Name))
		b.WriteString(fmt.Sprintf("  %s(_input?: UnknownRecord): void {\n", toCamelCase(fn.Name)))
		b.WriteString("    // TODO: implement migrated logic\n")
		b.WriteString("  }\n\n")
	}
	b.WriteString("}\n")
	return b.String()
}

func generateModels(types []*ir.DataType) string {
	var b strings.Builder
	b.WriteString("/* Generated by Anvil. */\n\n")
	b.WriteString("export type UnknownRecord = Record<string, unknown>;\n\n")

	// Keep output stable.
	sorted := append([]*ir.DataType(nil), types...)
	sort.Slice(sorted, func(i, j int) bool { return sorted[i].Name < sorted[j].Name })

	for _, dt := range sorted {
		if dt == nil || dt.Kind != ir.TypeStruct {
			continue
		}
		b.WriteString(fmt.Sprintf("export interface %s {\n", toPascalCase(dt.Name)))
		for _, f := range dt.Fields {
			if f == nil {
				continue
			}
			b.WriteString(fmt.Sprintf("  %s?: %s;\n", toCamelCase(f.Name), mapType(f)))
		}
		b.WriteString("}\n\n")
	}
	return b.String()
}

func generateIndex(mods []*ir.Module) string {
	var b strings.Builder
	b.WriteString("/* Generated by Anvil. */\n\n")
	b.WriteString("export * from \"./model\";\n")
	for _, m := range mods {
		b.WriteString(fmt.Sprintf("export * from \"./%s\";\n", toKebabCase(m.Name)))
	}
	return b.String()
}

func mapType(dt *ir.DataType) string {
	if dt == nil {
		return "unknown"
	}
	switch dt.Kind {
	case ir.TypeString:
		return "string"
	case ir.TypeInteger, ir.TypeDecimal:
		return "number"
	case ir.TypeBoolean:
		return "boolean"
	case ir.TypeArray:
		if dt.ElementType != nil {
			return "Array<" + mapType(dt.ElementType) + ">"
		}
		return "Array<unknown>"
	case ir.TypeStruct:
		return toPascalCase(dt.Name)
	default:
		return "unknown"
	}
}

func toPascalCase(name string) string {
	parts := strings.FieldsFunc(name, func(r rune) bool {
		return r == '-' || r == '_' || r == ' ' || r == '.'
	})
	var out string
	for _, p := range parts {
		if p == "" {
			continue
		}
		out += strings.ToUpper(p[:1]) + strings.ToLower(p[1:])
	}
	if out == "" {
		return "Generated"
	}
	return out
}

func toCamelCase(name string) string {
	p := toPascalCase(name)
	if p == "" {
		return "unnamed"
	}
	return strings.ToLower(p[:1]) + p[1:]
}

func toKebabCase(name string) string {
	// Best-effort normalization for filenames.
	s := strings.TrimSpace(strings.ToLower(name))
	s = strings.NewReplacer("::", "-", ".", "-", "_", "-", " ", "-").Replace(s)
	for strings.Contains(s, "--") {
		s = strings.ReplaceAll(s, "--", "-")
	}
	s = strings.Trim(s, "-")
	if s == "" {
		return "generated"
	}
	return s
}

const packageJSON = `{
  "name": "anvil-generated",
  "private": true,
  "type": "module",
  "scripts": {
    "build": "tsc -p tsconfig.json",
    "typecheck": "tsc -p tsconfig.json --noEmit"
  },
  "dependencies": {
    "decimal.js": "^10.4.3"
  },
  "devDependencies": {
    "@types/node": "^20.0.0",
    "typescript": "^5.0.0"
  }
}
`

const tsconfigJSON = `{
  "compilerOptions": {
    "target": "ES2022",
    "module": "ES2022",
    "moduleResolution": "Bundler",
    "strict": true,
    "declaration": true,
    "outDir": "dist",
    "rootDir": "src"
  },
  "include": ["src/**/*.ts"]
}
`

const anvilManifestJSON = `{
  "version": "1",
  "language": "typescript",
  "compile": [
    { "cmd": "tsc", "args": ["-p", "tsconfig.json"] }
  ],
  "run_fixture": { "cmd": "node", "args": ["dist/anvil_runner.js"] }
}
`

const anvilRunnerTS = `/* Generated by Anvil. */
import fs from "node:fs";

type Fixture = {
  kind: string;
  name: string;
  correlation_id?: string;
  http?: { method: string; path: string; header?: Record<string, string>; body?: unknown };
  batch?: unknown;
};

type ActualOutput = {
  status?: number;
  headers?: Record<string, string>;
  body?: unknown;
};

function readStdin(): string {
  return fs.readFileSync(0, "utf8");
}

function main() {
  const raw = readStdin();
  let fixture: Fixture | null = null;
  try {
    fixture = JSON.parse(raw) as Fixture;
  } catch {
    // ignore
  }

  const out: ActualOutput = {
    status: 501,
    headers: { "content-type": "application/json" },
    body: { error: "not implemented", fixture: fixture?.name ?? null }
  };

  process.stdout.write(JSON.stringify(out));
}

main();
`
