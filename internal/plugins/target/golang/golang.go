package golang

import (
	"context"
	"fmt"
	"sort"
	"strings"
	"sync"

	"github.com/efebarandurmaz/anvil/internal/ir"
	"github.com/efebarandurmaz/anvil/internal/llm"
	"github.com/efebarandurmaz/anvil/internal/plugins"
)

// Plugin implements TargetPlugin for Go.
type Plugin struct{}

func New() *Plugin { return &Plugin{} }

func (p *Plugin) Language() string { return "go" }

func (p *Plugin) Generate(ctx context.Context, graph *ir.SemanticGraph, provider llm.Provider) ([]plugins.GeneratedFile, error) {
	var files []plugins.GeneratedFile

	files = append(files, plugins.GeneratedFile{
		Path:    "generated/model.go",
		Content: []byte(generateModels(graph.DataTypes)),
	})

	for _, mod := range graph.Modules {
		var content string
		if provider != nil {
			content = generateModuleWithLLM(ctx, mod, graph, provider)
		} else {
			content = generateModule(mod)
		}
		files = append(files, plugins.GeneratedFile{
			Path:    fmt.Sprintf("generated/%s.go", toSnakeFile(mod.Name)),
			Content: []byte(content),
		})
	}

	files = append(files, plugins.GeneratedFile{
		Path:    "cmd/app/main.go",
		Content: []byte(mainGo),
	})

	return files, nil
}

// generateModuleWithLLM generates Go module with LLM assistance.
func generateModuleWithLLM(ctx context.Context, mod *ir.Module, graph *ir.SemanticGraph, provider llm.Provider) string {
	var b strings.Builder
	b.WriteString("// Code generated by Anvil with LLM assistance. DO NOT EDIT.\n\n")
	b.WriteString("package generated\n\n")
	b.WriteString(fmt.Sprintf("type %sService struct{}\n\n", toPascalCase(mod.Name)))

	// Generate functions concurrently with worker pool
	const maxConcurrent = 1
	sem := make(chan struct{}, maxConcurrent)
	var wg sync.WaitGroup
	var mu sync.Mutex

	results := make([]string, len(mod.Functions))

	for i, fn := range mod.Functions {
		wg.Add(1)
		sem <- struct{}{} // acquire
		go func(idx int, f *ir.Function) {
			defer wg.Done()
			defer func() { <-sem }() // release

			impl := generateGoFunctionWithLLM(ctx, mod, f, graph, provider)

			mu.Lock()
			results[idx] = impl
			mu.Unlock()
		}(i, fn)
	}
	wg.Wait()

	// Write results in order
	for _, impl := range results {
		b.WriteString(impl)
	}

	return b.String()
}

// stripMarkdownFences removes markdown code fences from LLM output.
func stripMarkdownFences(s string) string {
	s = llm.StripThinkingTags(s)
	lines := strings.Split(s, "\n")

	// Find and remove leading fence
	start := 0
	for i, line := range lines {
		trimmed := strings.TrimSpace(line)
		if strings.HasPrefix(trimmed, "```") {
			start = i + 1
			break
		}
	}

	// Find and remove trailing fence
	end := len(lines)
	for i := len(lines) - 1; i >= start; i-- {
		trimmed := strings.TrimSpace(lines[i])
		if strings.HasPrefix(trimmed, "```") {
			end = i
			break
		}
	}

	// If no fences found, return original
	if start == 0 && end == len(lines) {
		return s
	}

	return strings.Join(lines[start:end], "\n")
}

// sanitizeLLMOutput strips Go-specific boilerplate that LLMs commonly include:
// package declarations, import blocks, and trailing prose.
func sanitizeLLMOutput(s string) string {
	lines := strings.Split(s, "\n")
	var cleaned []string
	inImportBlock := false
	for _, line := range lines {
		trimmed := strings.TrimSpace(line)

		// Skip package declarations
		if strings.HasPrefix(trimmed, "package ") {
			continue
		}

		// Detect and skip multi-line import blocks: import (...)
		if trimmed == "import (" {
			inImportBlock = true
			continue
		}
		if inImportBlock {
			if trimmed == ")" {
				inImportBlock = false
			}
			continue
		}

		// Skip single-line import statements: import "pkg" or import alias "pkg"
		if strings.HasPrefix(trimmed, "import ") {
			continue
		}

		// Strip trailing prose
		if strings.HasPrefix(trimmed, "This ") || strings.HasPrefix(trimmed, "Note:") ||
			strings.HasPrefix(trimmed, "The above") || strings.HasPrefix(trimmed, "Here ") {
			break
		}

		cleaned = append(cleaned, line)
	}

	// Trim leading/trailing empty lines
	for len(cleaned) > 0 && strings.TrimSpace(cleaned[0]) == "" {
		cleaned = cleaned[1:]
	}
	for len(cleaned) > 0 && strings.TrimSpace(cleaned[len(cleaned)-1]) == "" {
		cleaned = cleaned[:len(cleaned)-1]
	}

	return strings.Join(cleaned, "\n")
}

// generateGoFunctionWithLLM generates a Go function using LLM.
func generateGoFunctionWithLLM(ctx context.Context, mod *ir.Module, fn *ir.Function, graph *ir.SemanticGraph, provider llm.Provider) string {
	srcLang := mod.Language
	if srcLang == "" {
		srcLang = "legacy"
	}

	// Build context for LLM
	var fnCtx strings.Builder
	fnCtx.WriteString(fmt.Sprintf("Module: %s\n", mod.Name))
	fnCtx.WriteString(fmt.Sprintf("Function: %s\n", fn.Name))
	if fn.Body != "" {
		fnCtx.WriteString(fmt.Sprintf("Original %s Body:\n%s\n", srcLang, fn.Body))
	}

	// Include business rules
	for _, rule := range graph.BusinessRules {
		if rule.SourceRef == fmt.Sprintf("%s.%s", mod.Name, fn.Name) {
			fnCtx.WriteString(fmt.Sprintf("Business Rule: %s\n", rule.Description))
		}
	}

	prompt := &llm.Prompt{
		SystemPrompt: fmt.Sprintf(`You are a %s to Go migration expert. Generate clean, idiomatic Go code.
Rules:
1. Preserve exact business logic from the original %s source
2. Use idiomatic Go patterns (error handling, interfaces, etc.)
3. Add comments explaining the business logic
4. Handle edge cases with proper error returns
5. Return ONLY the function body (no func signature, no receiver)
6. CRITICAL: Use shopspring/decimal for ALL financial/monetary calculations to preserve precision
   - import "github.com/shopspring/decimal"
   - Use: decimal.NewFromString("10.50").Add(decimal.NewFromString("5.25"))
   - Never use float64 for money`, srcLang, srcLang),
		Messages: []llm.Message{
			{Role: llm.RoleUser, Content: fmt.Sprintf("Convert this %s function to Go:\n\n%s", srcLang, fnCtx.String())},
		},
	}

	resp, err := provider.Complete(ctx, prompt, nil)
	if err != nil {
		// Fallback to stub
		return generateGoFunctionStub(mod, fn)
	}

	impl := strings.TrimSpace(stripMarkdownFences(resp.Content))
	impl = sanitizeLLMOutput(impl)

	var b strings.Builder
	b.WriteString(fmt.Sprintf("// %s is migrated from %s.%s\n", toPascalCase(fn.Name), mod.Name, fn.Name))
	b.WriteString(fmt.Sprintf("func (s *%sService) %s() {\n", toPascalCase(mod.Name), toPascalCase(fn.Name)))

	// Indent implementation
	for _, line := range strings.Split(impl, "\n") {
		b.WriteString("\t" + line + "\n")
	}
	b.WriteString("}\n\n")

	return b.String()
}

// generateGoFunctionStub generates a stub function.
func generateGoFunctionStub(mod *ir.Module, fn *ir.Function) string {
	var b strings.Builder
	b.WriteString(fmt.Sprintf("// Migrated from %s.%s\n", mod.Name, fn.Name))
	b.WriteString(fmt.Sprintf("func (s *%sService) %s() {\n", toPascalCase(mod.Name), toPascalCase(fn.Name)))
	b.WriteString("\t// TODO: implement migrated logic\n")
	b.WriteString("}\n\n")
	return b.String()
}

func (p *Plugin) Scaffold(_ context.Context, _ *ir.SemanticGraph) ([]plugins.GeneratedFile, error) {
	return []plugins.GeneratedFile{
		{Path: "anvil.manifest.json", Content: []byte(anvilManifestJSON)},
		{Path: "go.mod", Content: []byte(goMod)},
		{Path: "cmd/anvil_runner/main.go", Content: []byte(anvilRunnerGo)},
	}, nil
}

func generateModels(types []*ir.DataType) string {
	var b strings.Builder
	b.WriteString("// Code generated by Anvil. DO NOT EDIT.\n\n")
	b.WriteString("package generated\n\n")

	sorted := append([]*ir.DataType(nil), types...)
	sort.Slice(sorted, func(i, j int) bool { return sorted[i].Name < sorted[j].Name })

	needDecimal := false
	for _, dt := range sorted {
		if dt == nil {
			continue
		}
		if dt.Kind == ir.TypeDecimal {
			needDecimal = true
		}
		for _, f := range dt.Fields {
			if f != nil && f.Kind == ir.TypeDecimal {
				needDecimal = true
			}
		}
	}
	if needDecimal {
		b.WriteString("import \"github.com/shopspring/decimal\"\n\n")
	}

	for _, dt := range sorted {
		if dt == nil || dt.Kind != ir.TypeStruct {
			continue
		}
		b.WriteString(fmt.Sprintf("type %s struct {\n", toPascalCase(dt.Name)))
		for _, f := range dt.Fields {
			if f == nil {
				continue
			}
			b.WriteString(fmt.Sprintf("\t%s %s `json:\"%s,omitempty\"`\n", toPascalCase(f.Name), mapType(f), toJSONName(f.Name)))
		}
		b.WriteString("}\n\n")
	}
	return b.String()
}

func generateModule(mod *ir.Module) string {
	var b strings.Builder
	b.WriteString("// Code generated by Anvil. DO NOT EDIT.\n\n")
	b.WriteString("package generated\n\n")
	b.WriteString(fmt.Sprintf("type %sService struct{}\n\n", toPascalCase(mod.Name)))
	for _, fn := range mod.Functions {
		b.WriteString(fmt.Sprintf("// Migrated from %s.%s\n", mod.Name, fn.Name))
		b.WriteString(fmt.Sprintf("func (s *%sService) %s() {\n", toPascalCase(mod.Name), toPascalCase(fn.Name)))
		b.WriteString("\t// TODO: implement migrated logic\n")
		b.WriteString("}\n\n")
	}
	return b.String()
}

func mapType(dt *ir.DataType) string {
	if dt == nil {
		return "any"
	}
	switch dt.Kind {
	case ir.TypeString:
		return "string"
	case ir.TypeInteger:
		if dt.Size > 9 {
			return "int64"
		}
		return "int"
	case ir.TypeDecimal:
		// Use shopspring/decimal for financial precision
		return "decimal.Decimal"
	case ir.TypeBoolean:
		return "bool"
	case ir.TypeArray:
		if dt.ElementType != nil {
			return "[]" + mapType(dt.ElementType)
		}
		return "[]any"
	case ir.TypeStruct:
		return toPascalCase(dt.Name)
	default:
		return "any"
	}
}

func toPascalCase(name string) string {
	parts := strings.FieldsFunc(name, func(r rune) bool {
		return r == '-' || r == '_' || r == ' ' || r == '.'
	})
	var out string
	for _, p := range parts {
		if p == "" {
			continue
		}
		out += strings.ToUpper(p[:1]) + strings.ToLower(p[1:])
	}
	if out == "" {
		return "Generated"
	}
	return out
}

func toSnakeFile(name string) string {
	s := strings.TrimSpace(strings.ToLower(name))
	s = strings.NewReplacer("::", "_", ".", "_", "-", "_", " ", "_").Replace(s)
	for strings.Contains(s, "__") {
		s = strings.ReplaceAll(s, "__", "_")
	}
	s = strings.Trim(s, "_")
	if s == "" {
		return "generated"
	}
	return s
}

func toJSONName(name string) string {
	s := strings.TrimSpace(strings.ToLower(name))
	s = strings.NewReplacer("::", "_", ".", "_", "-", "_", " ", "_").Replace(s)
	for strings.Contains(s, "__") {
		s = strings.ReplaceAll(s, "__", "_")
	}
	s = strings.Trim(s, "_")
	if s == "" {
		return "field"
	}
	return s
}

const goMod = `module anvil-generated

go 1.22

require github.com/shopspring/decimal v1.4.0
`

const anvilManifestJSON = `{
  "version": "1",
  "language": "go",
  "compile": [
    { "cmd": "go", "args": ["test", "./..."] },
    { "cmd": "go", "args": ["build", "-o", "bin/anvil_runner", "./cmd/anvil_runner"] }
  ],
  "run_fixture": { "cmd": "./bin/anvil_runner" }
}
`

const mainGo = `package main

import _ "anvil-generated/generated"

func main() {
}
`

const anvilRunnerGo = `package main

import (
	"encoding/json"
	"os"
)

type fixture struct {
	Kind string ` + "`json:\"kind\"`" + `
	Name string ` + "`json:\"name\"`" + `
}

type actualOutput struct {
	Status  int               ` + "`json:\"status\"`" + `
	Headers map[string]string ` + "`json:\"headers,omitempty\"`" + `
	Body    any               ` + "`json:\"body,omitempty\"`" + `
}

func main() {
	var f fixture
	dec := json.NewDecoder(os.Stdin)
	_ = dec.Decode(&f)

	out := actualOutput{
		Status:  501,
		Headers: map[string]string{"content-type": "application/json"},
		Body:    map[string]any{"error": "not implemented", "fixture": f.Name},
	}
	enc := json.NewEncoder(os.Stdout)
	_ = enc.Encode(out)
}
`
