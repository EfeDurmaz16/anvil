package golang

import (
	"context"
	"fmt"
	"sort"
	"strings"

	"github.com/efebarandurmaz/anvil/internal/ir"
	"github.com/efebarandurmaz/anvil/internal/llm"
	"github.com/efebarandurmaz/anvil/internal/plugins"
)

// Plugin implements TargetPlugin for Go.
type Plugin struct{}

func New() *Plugin { return &Plugin{} }

func (p *Plugin) Language() string { return "go" }

func (p *Plugin) Generate(ctx context.Context, graph *ir.SemanticGraph, provider llm.Provider) ([]plugins.GeneratedFile, error) {
	var files []plugins.GeneratedFile

	files = append(files, plugins.GeneratedFile{
		Path:    "generated/model.go",
		Content: []byte(generateModels(graph.DataTypes)),
	})

	for _, mod := range graph.Modules {
		var content string
		if provider != nil {
			content = generateModuleWithLLM(ctx, mod, graph, provider)
		} else {
			content = generateModule(mod)
		}
		files = append(files, plugins.GeneratedFile{
			Path:    fmt.Sprintf("generated/%s.go", toSnakeFile(mod.Name)),
			Content: []byte(content),
		})
	}

	files = append(files, plugins.GeneratedFile{
		Path:    "cmd/app/main.go",
		Content: []byte(mainGo),
	})

	return files, nil
}

// generateModuleWithLLM generates Go module with LLM assistance.
func generateModuleWithLLM(ctx context.Context, mod *ir.Module, graph *ir.SemanticGraph, provider llm.Provider) string {
	var b strings.Builder
	b.WriteString("// Code generated by Anvil with LLM assistance. DO NOT EDIT.\n\n")
	b.WriteString("package generated\n\n")
	b.WriteString(fmt.Sprintf("type %sService struct{}\n\n", toPascalCase(mod.Name)))

	for _, fn := range mod.Functions {
		impl := generateGoFunctionWithLLM(ctx, mod, fn, graph, provider)
		b.WriteString(impl)
	}

	return b.String()
}

// generateGoFunctionWithLLM generates a Go function using LLM.
func generateGoFunctionWithLLM(ctx context.Context, mod *ir.Module, fn *ir.Function, graph *ir.SemanticGraph, provider llm.Provider) string {
	// Build context for LLM
	var fnCtx strings.Builder
	fnCtx.WriteString(fmt.Sprintf("Module: %s\n", mod.Name))
	fnCtx.WriteString(fmt.Sprintf("Function: %s\n", fn.Name))
	if fn.Body != "" {
		fnCtx.WriteString(fmt.Sprintf("Original COBOL Body:\n%s\n", fn.Body))
	}

	// Include business rules
	for _, rule := range graph.BusinessRules {
		if rule.SourceRef == fmt.Sprintf("%s.%s", mod.Name, fn.Name) {
			fnCtx.WriteString(fmt.Sprintf("Business Rule: %s\n", rule.Description))
		}
	}

	prompt := &llm.Prompt{
		SystemPrompt: `You are a COBOL to Go migration expert. Generate clean, idiomatic Go code.
Rules:
1. Preserve exact business logic from the original COBOL
2. Use idiomatic Go patterns (error handling, interfaces, etc.)
3. Add comments explaining the business logic
4. Handle edge cases with proper error returns
5. Return ONLY the function body (no func signature, no receiver)
6. CRITICAL: Use shopspring/decimal for ALL financial/monetary calculations to preserve COBOL precision
   - import "github.com/shopspring/decimal"
   - Use: decimal.NewFromString("10.50").Add(decimal.NewFromString("5.25"))
   - Never use float64 for money`,
		Messages: []llm.Message{
			{Role: llm.RoleUser, Content: fmt.Sprintf("Convert this COBOL function to Go:\n\n%s", fnCtx.String())},
		},
	}

	resp, err := provider.Complete(ctx, prompt, nil)
	if err != nil {
		// Fallback to stub
		return generateGoFunctionStub(mod, fn)
	}

	impl := strings.TrimSpace(resp.Content)

	var b strings.Builder
	b.WriteString(fmt.Sprintf("// %s is migrated from %s.%s\n", toPascalCase(fn.Name), mod.Name, fn.Name))
	b.WriteString(fmt.Sprintf("func (s *%sService) %s() {\n", toPascalCase(mod.Name), toPascalCase(fn.Name)))

	// Indent implementation
	for _, line := range strings.Split(impl, "\n") {
		b.WriteString("\t" + line + "\n")
	}
	b.WriteString("}\n\n")

	return b.String()
}

// generateGoFunctionStub generates a stub function.
func generateGoFunctionStub(mod *ir.Module, fn *ir.Function) string {
	var b strings.Builder
	b.WriteString(fmt.Sprintf("// Migrated from %s.%s\n", mod.Name, fn.Name))
	b.WriteString(fmt.Sprintf("func (s *%sService) %s() {\n", toPascalCase(mod.Name), toPascalCase(fn.Name)))
	b.WriteString("\t// TODO: implement migrated logic\n")
	b.WriteString("}\n\n")
	return b.String()
}

func (p *Plugin) Scaffold(_ context.Context, _ *ir.SemanticGraph) ([]plugins.GeneratedFile, error) {
	return []plugins.GeneratedFile{
		{Path: "anvil.manifest.json", Content: []byte(anvilManifestJSON)},
		{Path: "go.mod", Content: []byte(goMod)},
		{Path: "cmd/anvil_runner/main.go", Content: []byte(anvilRunnerGo)},
	}, nil
}

func generateModels(types []*ir.DataType) string {
	var b strings.Builder
	b.WriteString("// Code generated by Anvil. DO NOT EDIT.\n\n")
	b.WriteString("package generated\n\n")

	sorted := append([]*ir.DataType(nil), types...)
	sort.Slice(sorted, func(i, j int) bool { return sorted[i].Name < sorted[j].Name })

	needDecimal := false
	for _, dt := range sorted {
		if dt == nil {
			continue
		}
		if dt.Kind == ir.TypeDecimal {
			needDecimal = true
		}
		for _, f := range dt.Fields {
			if f != nil && f.Kind == ir.TypeDecimal {
				needDecimal = true
			}
		}
	}
	if needDecimal {
		b.WriteString("import \"github.com/shopspring/decimal\"\n\n")
	}

	for _, dt := range sorted {
		if dt == nil || dt.Kind != ir.TypeStruct {
			continue
		}
		b.WriteString(fmt.Sprintf("type %s struct {\n", toPascalCase(dt.Name)))
		for _, f := range dt.Fields {
			if f == nil {
				continue
			}
			b.WriteString(fmt.Sprintf("\t%s %s `json:\"%s,omitempty\"`\n", toPascalCase(f.Name), mapType(f), toJSONName(f.Name)))
		}
		b.WriteString("}\n\n")
	}
	return b.String()
}

func generateModule(mod *ir.Module) string {
	var b strings.Builder
	b.WriteString("// Code generated by Anvil. DO NOT EDIT.\n\n")
	b.WriteString("package generated\n\n")
	b.WriteString(fmt.Sprintf("type %sService struct{}\n\n", toPascalCase(mod.Name)))
	for _, fn := range mod.Functions {
		b.WriteString(fmt.Sprintf("// Migrated from %s.%s\n", mod.Name, fn.Name))
		b.WriteString(fmt.Sprintf("func (s *%sService) %s() {\n", toPascalCase(mod.Name), toPascalCase(fn.Name)))
		b.WriteString("\t// TODO: implement migrated logic\n")
		b.WriteString("}\n\n")
	}
	return b.String()
}

func mapType(dt *ir.DataType) string {
	if dt == nil {
		return "any"
	}
	switch dt.Kind {
	case ir.TypeString:
		return "string"
	case ir.TypeInteger:
		if dt.Size > 9 {
			return "int64"
		}
		return "int"
	case ir.TypeDecimal:
		// Use shopspring/decimal for COBOL precision
		return "decimal.Decimal"
	case ir.TypeBoolean:
		return "bool"
	case ir.TypeArray:
		if dt.ElementType != nil {
			return "[]" + mapType(dt.ElementType)
		}
		return "[]any"
	case ir.TypeStruct:
		return toPascalCase(dt.Name)
	default:
		return "any"
	}
}

func toPascalCase(name string) string {
	parts := strings.FieldsFunc(name, func(r rune) bool {
		return r == '-' || r == '_' || r == ' ' || r == '.'
	})
	var out string
	for _, p := range parts {
		if p == "" {
			continue
		}
		out += strings.ToUpper(p[:1]) + strings.ToLower(p[1:])
	}
	if out == "" {
		return "Generated"
	}
	return out
}

func toSnakeFile(name string) string {
	s := strings.TrimSpace(strings.ToLower(name))
	s = strings.NewReplacer("::", "_", ".", "_", "-", "_", " ", "_").Replace(s)
	for strings.Contains(s, "__") {
		s = strings.ReplaceAll(s, "__", "_")
	}
	s = strings.Trim(s, "_")
	if s == "" {
		return "generated"
	}
	return s
}

func toJSONName(name string) string {
	s := strings.TrimSpace(strings.ToLower(name))
	s = strings.NewReplacer("::", "_", ".", "_", "-", "_", " ", "_").Replace(s)
	for strings.Contains(s, "__") {
		s = strings.ReplaceAll(s, "__", "_")
	}
	s = strings.Trim(s, "_")
	if s == "" {
		return "field"
	}
	return s
}

const goMod = `module anvil-generated

go 1.22

require github.com/shopspring/decimal v1.4.0
`

const anvilManifestJSON = `{
  "version": "1",
  "language": "go",
  "compile": [
    { "cmd": "go", "args": ["test", "./..."] },
    { "cmd": "go", "args": ["build", "-o", "bin/anvil_runner", "./cmd/anvil_runner"] }
  ],
  "run_fixture": { "cmd": "./bin/anvil_runner" }
}
`

const mainGo = `package main

import _ "anvil-generated/generated"

func main() {
}
`

const anvilRunnerGo = `package main

import (
	"encoding/json"
	"os"
)

type fixture struct {
	Kind string ` + "`json:\"kind\"`" + `
	Name string ` + "`json:\"name\"`" + `
}

type actualOutput struct {
	Status  int               ` + "`json:\"status\"`" + `
	Headers map[string]string ` + "`json:\"headers,omitempty\"`" + `
	Body    any               ` + "`json:\"body,omitempty\"`" + `
}

func main() {
	var f fixture
	dec := json.NewDecoder(os.Stdin)
	_ = dec.Decode(&f)

	out := actualOutput{
		Status:  501,
		Headers: map[string]string{"content-type": "application/json"},
		Body:    map[string]any{"error": "not implemented", "fixture": f.Name},
	}
	enc := json.NewEncoder(os.Stdout)
	_ = enc.Encode(out)
}
`
