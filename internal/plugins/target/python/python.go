package python

import (
	"context"
	"fmt"
	"sort"
	"strings"

	"github.com/efebarandurmaz/anvil/internal/ir"
	"github.com/efebarandurmaz/anvil/internal/llm"
	"github.com/efebarandurmaz/anvil/internal/plugins"
)

// Plugin implements TargetPlugin for Python.
type Plugin struct{}

func New() *Plugin { return &Plugin{} }

func (p *Plugin) Language() string { return "python" }

func (p *Plugin) Generate(ctx context.Context, graph *ir.SemanticGraph, provider llm.Provider) ([]plugins.GeneratedFile, error) {
	var files []plugins.GeneratedFile

	files = append(files, plugins.GeneratedFile{
		Path:    "src/anvil_generated/model.py",
		Content: []byte(generateModels(graph.DataTypes)),
	})

	for _, mod := range graph.Modules {
		var content string
		if provider != nil {
			content = generateModuleWithLLM(ctx, mod, graph, provider)
		} else {
			content = generateModule(mod)
		}
		files = append(files, plugins.GeneratedFile{
			Path:    fmt.Sprintf("src/anvil_generated/%s.py", toSnakeFile(mod.Name)),
			Content: []byte(content),
		})
	}

	return files, nil
}

// generateModuleWithLLM generates Python module with LLM assistance.
func generateModuleWithLLM(ctx context.Context, mod *ir.Module, graph *ir.SemanticGraph, provider llm.Provider) string {
	var b strings.Builder
	b.WriteString("# Generated by Anvil with LLM assistance.\n")
	b.WriteString("from __future__ import annotations\n\n")
	b.WriteString("from .model import UnknownRecord\n\n\n")
	b.WriteString(fmt.Sprintf("class %sService:\n", toPascalCase(mod.Name)))

	if len(mod.Functions) == 0 {
		b.WriteString("    pass\n")
		return b.String()
	}

	for _, fn := range mod.Functions {
		impl := generatePythonFunctionWithLLM(ctx, mod, fn, graph, provider)
		b.WriteString(impl)
	}

	return b.String()
}

// generatePythonFunctionWithLLM generates a Python function using LLM.
func generatePythonFunctionWithLLM(ctx context.Context, mod *ir.Module, fn *ir.Function, graph *ir.SemanticGraph, provider llm.Provider) string {
	// Build context for LLM
	var fnCtx strings.Builder
	fnCtx.WriteString(fmt.Sprintf("Module: %s\n", mod.Name))
	fnCtx.WriteString(fmt.Sprintf("Function: %s\n", fn.Name))
	if fn.Body != "" {
		lang := mod.Language
		if lang == "" {
			lang = "legacy"
		}
		fnCtx.WriteString(fmt.Sprintf("Original %s Body:\n%s\n", lang, fn.Body))
	}

	// Include business rules
	for _, rule := range graph.BusinessRules {
		if rule.SourceRef == fmt.Sprintf("%s.%s", mod.Name, fn.Name) {
			fnCtx.WriteString(fmt.Sprintf("Business Rule: %s\n", rule.Description))
		}
	}

	lang := mod.Language
	if lang == "" {
		lang = "legacy"
	}

	prompt := &llm.Prompt{
		SystemPrompt: fmt.Sprintf(`You are a %s to Python migration expert. Generate clean, idiomatic Python code.
Rules:
1. Preserve exact business logic from the original %s
2. Use modern Python features (type hints, dataclasses, etc.)
3. Add docstrings explaining the business logic
4. Handle edge cases appropriately
5. Return ONLY the function body (no class wrapper, no def line)
6. CRITICAL: Use stdlib decimal.Decimal for ALL financial/monetary calculations to preserve %s precision
   - from decimal import Decimal
   - Use: Decimal('10.50') + Decimal('5.25')
   - Never use float for money`, lang, lang, lang),
		Messages: []llm.Message{
			{Role: llm.RoleUser, Content: fmt.Sprintf("Convert this %s function to Python:\n\n%s", lang, fnCtx.String())},
		},
	}

	resp, err := provider.Complete(ctx, prompt, nil)
	if err != nil {
		// Fallback to stub
		return generatePythonFunctionStub(mod, fn)
	}

	impl := strings.TrimSpace(resp.Content)

	var b strings.Builder
	b.WriteString(fmt.Sprintf("    def %s(self, _input: UnknownRecord | None = None) -> None:\n", toSnakeIdent(fn.Name)))
	b.WriteString(fmt.Sprintf("        \"\"\"Migrated from %s.%s\"\"\"\n", mod.Name, fn.Name))

	// Indent implementation
	for _, line := range strings.Split(impl, "\n") {
		b.WriteString("        " + line + "\n")
	}
	b.WriteString("\n")

	return b.String()
}

// generatePythonFunctionStub generates a stub function.
func generatePythonFunctionStub(mod *ir.Module, fn *ir.Function) string {
	var b strings.Builder
	b.WriteString(fmt.Sprintf("    def %s(self, _input: UnknownRecord | None = None) -> None:\n", toSnakeIdent(fn.Name)))
	b.WriteString(fmt.Sprintf("        \"\"\"Migrated from %s.%s\"\"\"\n", mod.Name, fn.Name))
	b.WriteString("        # TODO: implement migrated logic\n")
	b.WriteString("        _ = _input\n")
	b.WriteString("        return None\n\n")
	return b.String()
}

func (p *Plugin) Scaffold(_ context.Context, _ *ir.SemanticGraph) ([]plugins.GeneratedFile, error) {
	return []plugins.GeneratedFile{
		{Path: "anvil.manifest.json", Content: []byte(anvilManifestJSON)},
		{Path: "pyproject.toml", Content: []byte(pyprojectTOML)},
		{Path: "README.md", Content: []byte("# anvil-generated\n\nGenerated by Anvil.\n")},
		{Path: "src/anvil_generated/__init__.py", Content: []byte("# Generated by Anvil.\n")},
		{Path: "src/anvil_generated/runner.py", Content: []byte(anvilRunnerPY)},
	}, nil
}

func generateModule(mod *ir.Module) string {
	var b strings.Builder
	b.WriteString("# Generated by Anvil.\n")
	b.WriteString("from __future__ import annotations\n\n")
	b.WriteString("from .model import UnknownRecord\n\n\n")
	b.WriteString(fmt.Sprintf("class %sService:\n", toPascalCase(mod.Name)))
	if len(mod.Functions) == 0 {
		b.WriteString("    pass\n")
		return b.String()
	}
	for _, fn := range mod.Functions {
		b.WriteString(fmt.Sprintf("    def %s(self, _input: UnknownRecord | None = None) -> None:\n", toSnakeIdent(fn.Name)))
		b.WriteString(fmt.Sprintf("        \"\"\"Migrated from %s.%s\"\"\"\n", mod.Name, fn.Name))
		b.WriteString("        # TODO: implement migrated logic\n")
		b.WriteString("        _ = _input\n")
		b.WriteString("        return None\n\n")
	}
	return b.String()
}

func generateModels(types []*ir.DataType) string {
	var b strings.Builder
	b.WriteString("# Generated by Anvil.\n")
	b.WriteString("from __future__ import annotations\n\n")

	needDecimal := false

	sorted := append([]*ir.DataType(nil), types...)
	sort.Slice(sorted, func(i, j int) bool { return sorted[i].Name < sorted[j].Name })
	for _, dt := range sorted {
		if dt != nil && dt.Kind == ir.TypeDecimal {
			needDecimal = true
		}
		for _, f := range dt.Fields {
			if f != nil && f.Kind == ir.TypeDecimal {
				needDecimal = true
			}
		}
	}

	b.WriteString("from dataclasses import dataclass\n")
	if needDecimal {
		b.WriteString("from decimal import Decimal\n")
	}
	b.WriteString("from typing import Any\n\n")
	b.WriteString("UnknownRecord = dict[str, Any]\n\n\n")

	for _, dt := range sorted {
		if dt == nil || dt.Kind != ir.TypeStruct {
			continue
		}
		b.WriteString("@dataclass\n")
		b.WriteString(fmt.Sprintf("class %s:\n", toPascalCase(dt.Name)))
		if len(dt.Fields) == 0 {
			b.WriteString("    pass\n\n\n")
			continue
		}
		for _, f := range dt.Fields {
			if f == nil {
				continue
			}
			b.WriteString(fmt.Sprintf("    %s: %s | None = None\n", toSnakeIdent(f.Name), mapType(f)))
		}
		b.WriteString("\n\n")
	}

	return b.String()
}

func mapType(dt *ir.DataType) string {
	if dt == nil {
		return "Any"
	}
	switch dt.Kind {
	case ir.TypeString:
		return "str"
	case ir.TypeInteger:
		return "int"
	case ir.TypeDecimal:
		return "Decimal"
	case ir.TypeBoolean:
		return "bool"
	case ir.TypeArray:
		if dt.ElementType != nil {
			return "list[" + mapType(dt.ElementType) + "]"
		}
		return "list[Any]"
	case ir.TypeStruct:
		return toPascalCase(dt.Name)
	default:
		return "Any"
	}
}

func toPascalCase(name string) string {
	parts := strings.FieldsFunc(name, func(r rune) bool {
		return r == '-' || r == '_' || r == ' ' || r == '.'
	})
	var out string
	for _, p := range parts {
		if p == "" {
			continue
		}
		out += strings.ToUpper(p[:1]) + strings.ToLower(p[1:])
	}
	if out == "" {
		return "Generated"
	}
	return out
}

func toSnakeIdent(name string) string {
	s := strings.TrimSpace(strings.ToLower(name))
	s = strings.NewReplacer("::", "_", ".", "_", "-", "_", " ", "_").Replace(s)
	for strings.Contains(s, "__") {
		s = strings.ReplaceAll(s, "__", "_")
	}
	s = strings.Trim(s, "_")
	if s == "" {
		return "unnamed"
	}
	return s
}

func toSnakeFile(name string) string {
	return toSnakeIdent(name)
}

const pyprojectTOML = `[project]
name = "anvil-generated"
version = "0.0.0"
requires-python = ">=3.11"
`

const anvilManifestJSON = `{
  "version": "1",
  "language": "python",
  "compile": [
    { "cmd": "python3", "args": ["-m", "compileall", "-q", "src"] }
  ],
  "run_fixture": { "cmd": "python3", "args": ["-m", "anvil_generated.runner"], "env": { "PYTHONPATH": "src" } }
}
`

const anvilRunnerPY = `# Generated by Anvil.
from __future__ import annotations

import json
import sys


def main() -> None:
    raw = sys.stdin.read()
    try:
        fixture = json.loads(raw) if raw.strip() else {}
    except Exception:
        fixture = {}

    out = {
        "status": 501,
        "headers": {"content-type": "application/json"},
        "body": {"error": "not implemented", "fixture": fixture.get("name")},
    }
    sys.stdout.write(json.dumps(out))


if __name__ == "__main__":
    main()
`
