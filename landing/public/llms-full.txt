# Anvil - Complete Documentation for AI Agents

> Open-source multi-agent platform that modernizes legacy code (COBOL, Perl, Fortran) into modern TypeScript, Python, or Go — with enterprise regression gates and proof packs.

## Project Overview

Anvil is an open-source CLI tool and multi-agent system designed to modernize legacy mainframe and server codebases. It reads legacy source code written in COBOL, Perl, or Fortran, extracts the business logic, and generates modern target code via pluggable target plugins (TypeScript/Python/Go/Java/etc.).

### Why Anvil Exists

Legacy systems still power critical infrastructure in banking and telecom. Modernization is not just codegen: enterprise buyers require verifiable behavior equivalence, traceability, and on‑prem/VPC deployment options. Anvil targets those needs with deterministic builds, regression gates, and evidence bundles (proof packs).

## Architecture

### Multi-Agent Pipeline

Anvil uses a pipeline of four specialized AI agents:

#### 1. Cartographer (Parse & Map)
- Reads source files and builds a complete semantic graph
- Extracts modules, functions, data types, call graphs, control flow, and I/O contracts
- Tree-sitter parsing is optional (build tags); no LLM required
- Parses fixed-format COBOL (columns 1-72) with Area A/B detection
- Extracts IDENTIFICATION, DATA, and PROCEDURE divisions
- Builds call graphs from PERFORM, CALL, and GO TO statements
- Maps PIC clauses to typed IR nodes (PIC 9 → numeric, PIC X → string)
- Resolves COPY/INCLUDE copybook dependencies
- Detects EXEC CICS and EXEC SQL blocks for I/O classification
- Optionally stores semantic graph in Neo4j and generates embeddings in Qdrant

#### 2. Specular (Extract Business Rules)
- Uses LLM to analyze the semantic graph
- Extracts business rules, validation logic, and domain patterns
- Queries the semantic graph for complex conditional logic
- Identifies business rules embedded in EVALUATE/IF chains
- Extracts validation patterns (field-level, cross-field, temporal)
- Documents domain-specific terminology and naming conventions
- Scores complexity per function to prioritize review
- Works without LLM in template-only mode (rules are skipped)

#### 3. Architect (Generate Modern Code)
- Transforms the enriched IR into the chosen target runtime (TypeScript/Python/Go/…)
- Emits `anvil.manifest.json` (compile + runner commands) so harness/orchestration stays target-agnostic
- Uses an LLM for complex logic translation when available (local endpoints supported)
- Falls back to template-based generation in offline mode
- Preserves structure and naming for traceability

#### 4. Judge (Verify Equivalence)
- Validates that generated code preserves original semantics
- Accepts structured LLM verdicts (strict JSON) when enabled
- Combines semantic checks with regression gates (compile, fixtures/record-replay, DB diff)
- Produces a proof pack (diffs, logs, metadata) for enterprise reviewers
- On failure, provides feedback to Architect for retry

## Supported Languages

### Source Languages
- **COBOL** - Full support including CICS, DB2/SQL, copybooks, BMS maps
- **Perl** - Package modules, DBI database calls, file I/O
- **Fortran** - Modules, subroutines, functions, array operations

### Target Languages
- **TypeScript** - Node.js target runner + manifest
- **Python** - module runner + manifest
- **Go** - runner binary + manifest
- **Java** - available via plugin (demo/legacy target)

## Installation

### Using Go Install
```bash
go install github.com/efebarandurmaz/anvil/cmd/anvil@latest
```

### Building from Source
```bash
git clone https://github.com/EfeDurmaz16/anvil.git
cd anvil
make build
./bin/anvil --version
```

### Requirements
- Go version per `go.mod`
- Zero external runtime dependencies for basic operation

### Optional Dependencies (for full functionality)
- **Temporal.io** - Workflow orchestration (required for production pipelines)
- **Neo4j** - Graph database for semantic graph storage
- **Qdrant** - Vector database for semantic search and embeddings

## Usage

### Basic Command
```bash
anvil run --source cobol --target typescript \
    --input ./your-cobol-src \
    --output ./generated
```

### Regression Gate (Harness)
```bash
anvil harness run --fixtures ./fixtures.jsonl --code ./generated --output ./proof-pack
```

### CLI Reference
```
anvil run [flags]

Flags:
  --source string    Source language (default "cobol")
  --target string    Target language (default "java")
  --input string     Input directory or file (required)
  --output string    Output directory (required)
  --config string    Config file path (default "configs/anvil.yaml")
  --json             Output results as JSON
```

### Configuration File (anvil.yaml)
```yaml
# anvil.yaml (matches `configs/anvil.yaml` in the repo; env vars override with ANVIL_*).
llm:
  # provider: anthropic, openai, groq, huggingface, ollama, together, deepseek, custom, none
  provider: none
  model: ""
  api_key: ""
  base_url: ""
  temperature: 0.2
  max_tokens: 4096

graph:
  uri: bolt://localhost:7687
  username: neo4j
  password: ${NEO4J_PASSWORD}

vector:
  host: localhost
  port: 6334
  collection: anvil

temporal:
  host: localhost:7233
  namespace: default
  task_queue: anvil-tasks

log:
  level: info
  format: json
```

Target and source languages are selected via CLI/workflow input (e.g. `anvil run --source cobol --target typescript`).

## LLM Providers

Anvil supports multiple LLM providers through a unified interface (including local OpenAI-compatible endpoints such as Ollama/vLLM).

**Important:** LLM is optional. Anvil works fully offline with template-based generation. The Cartographer and Architect agents can run without any LLM. Adding an LLM provider enables business rule extraction via Specular and improves code quality.

## Example Transformations

### COBOL Calculator → Modern Service
Input: COBOL with PIC 9(7)V99 decimal types and COMPUTE statements
Output: Target code (TypeScript/Python/Go) with safe numeric handling (example output varies per target)

### CICS Sign-On → Service/API Adapter
Input: COBOL CICS program with EXEC CICS RECEIVE/SEND and BMS maps
Output: Modern service boundary with equivalent request/response behavior (validated via record/replay)

### Batch Report → Batch Runner
Input: COBOL batch program with sequential file I/O
Output: Target runner with deterministic inputs/outputs (validated via fixture diffs)

### DB CRUD → Persistence Layer
Input: COBOL with EXEC SQL INSERT/UPDATE/DELETE/SELECT
Output: Target persistence adapter (exact framework depends on target/runtime)

### Perl Bugzilla → Modern Service
Input: Perl package with DBI database calls and file I/O
Output: Target service with equivalent side effects and audit behavior

### Fortran Linear Algebra → Compute Module
Input: Fortran module with subroutines and array operations
Output: Target compute module (TypeScript/Python/Go), preserving numerical behavior

## Benchmarks

Enterprise-scale transformation of AWS CardDemo (61 COBOL files):
- 29 modules processed
- 546 functions mapped
- 2,032 data types converted
- SQL/CICS blocks mapped into target service boundaries (target-dependent)
- Regression gates validate fixtures + DB diffs (proof pack produced)

## Links

- **Website:** https://anvil-landing-one.vercel.app/
- **Interactive Demo:** https://anvil-landing-one.vercel.app/demo
- **Documentation:** https://anvil-landing-one.vercel.app/docs
- **GitHub Repository:** https://github.com/EfeDurmaz16/anvil
- **License:** MIT

## Contact

For issues and feature requests, please use the GitHub issue tracker:
https://github.com/EfeDurmaz16/anvil/issues
